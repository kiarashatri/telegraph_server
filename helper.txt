jwtObject (signed to: socket.data.user) = {
  user_id: string,
}

----------------------------------------------------------------------------------------------

 Middleware's : (middlewares.ts ) =>

  - 1.1 return `true` To continue connection
  - 1.2 return `false` To reject and disconnect client from server
  - 2.1 import function in middlewares.ts and add into middlewares array


----------------------------------------------------------------------------------------------


Emit's :

  Server-Side:
    - Private:
      - allUnreadMsgFromServer: join to user_id => get in once after connection from the client
      - singleUnreadMsgFromServer: Send Just to user_id => single message when sender , send message
      - sendUserProfile: (emit name: sendUserProfileFromServer) => send name,family, username, user_id, photo, biography, last_seen
      - sendLastSeenFromServer: array of users last_seen status => [{userId: id, lastSeen:Date}]
      - sendAllFollowingStorysInfoFromServer run fist at start conn to user
      - sendStoryPhotoFromServer:gets( {ownerId, ObjectId} ) :  return { status: bool,id: storyModelRequest.  _id, image: storyModelRequest.image};
      - sendTweetToClientFromServer : send array tweet to user by pagination
      - recieveTweetCommentsFromServer
      - SendFollowingListFromServer: returnObj -> { userId: string, following:array }
      

  Client-side:
    - newMessageFromClient: arg => {
      to: user_id,
      reply_to?: message_id,
      context: { image: "img", text: "string"}
    }
    - receiveUserProfile: arg: (userId of user we want) {
      based of server-side sendUserProfile emit: returns => name,family, username, user_id, photo, biography
    }
    - requestLastSeen: (arg: array of userId) => emit a list of users that we want their last seen
    - addNewTweet: tweetContext
    - toggleTweetLike: (args: tweetId) => toggle from db and return true | false
    - getComments : (args: tweetId, skipPage)
    - getTweetsOfAnUser : (args: userId, skipPage)
    - getFollowingListRequest: (arg: requestUserId) => {userId: string, following: array}
    - getBlockListRequest : => [ blockedUsers ]



  ----------------------------------------------------------------------------------------------


  db.users.insertOne({
    name: 'kia',
    family: 'atri',
    username: 'kiarashatri',
    email: 'kia@gmail.cm',
    phone: 91188301030,
    last_seen: null,
    register_time: null,
    email_confirmation: null,
    following: [ { id: 1, time_add: null },{ id: 2, time_add: null },{ id: 3, time_add: null } ],
    block: [ { id: 456, time_block: null } ],
    setting: null
  });

    const a2 = new message({
      from: socket.data.user.ObjectId,
      to: new Types.ObjectId(),
      context: {
        text: "hi this is test",
      },
    });

    await a2.save();


    await user.findByIdAndDelete("63021504584d11f17ccd739e");
    const a2 = new user({
      name: "john",
      family: "snow",
      hashPassword: "5joRzUcZu3OkKsFCjV5ydNgxYAWl+YbCeSL8uFJ2nC8=",
      username: "jhonsnow",
      email: "jhonsnow@email.com",
      photo: "base64Photohere",
      biography: "my jhonsnow bio here",
      phone: 91188301030,
      last_seen: new Date(),
      register_at: new Date(),
      email_confirmation: new Date(),
      following: [
        {
          id: new Types.ObjectId("62fc0c0c2b83bd50cb5fef05"),
          added_at: new Date(),
        },
        { id: new Types.ObjectId(), added_at: new Date() },
        { id: new Types.ObjectId(), added_at: new Date() },
      ],
      block: [{ id: new Types.ObjectId(), blocked_at: new Date() }],
      setting: {},
    });

    await a2.save();



        const d = sign(
      { user_id: "63021602091fa84d91c8e9bf" },
      "0684c60c14e870b7a16ad6f491cb896f232b46017a2b6c0261120bef5eba5100"
    );
    console.log(d);



     db.tweets.insertOne({
    owner: ObjectId("62fbb1a596ac46dda02af592"),
    likes: [ObjectId("63021602091fa84d91c8e9bf")],
    comments: [],
    context: 'im tweeting! brah',
    sent_at: ISODate("2022-08-17T17:15:37.718Z"),
  })